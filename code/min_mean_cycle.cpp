 Добавим к нашему графу вершину s и рёбра из неё во все остальные вершины. Запустим алгоритм Форда-Беллмана и попросим его построить нам квадратную матрицу со следующим условием: d[i][u] — длина минимального пути от s до u ровно из i ребер. Тогда длина оптимального цикла μ∗ минимального среднего веса вычисляется как minumaxkd[n][u]−d[k][u]n−k.

Достаточно будет доказать это правило для μ∗=0, так как для других μ∗ можно просто отнять эту величину от всех ребер и получить снова случай с μ∗=0.

Чтобы найти цикл после построения матрицы d[k][u], запомним, при каких u и k достигается оптимальное значение μ∗, и, используя d[n][u], поднимемся по указателям предков. Как только мы попадем в уже посещенную вершину — мы нашли цикл минимального среднего веса.

Этот алгоритм работает за O(VE)
 
 func findMinCycle(Graph G)
     // вводим мнимую вершину s, от которой проведём рёбра нулевого веса в каждую вершину графа
     Node s
     Edge[] e
     insert(s)   
     i = 0                                      
     for u in G
         e[i].begin = s
         e[i].end = u
         e[i].weight = 0
         i++
     // строим матрицу кратчайших расстояний, запустив алгоритм Форда-Беллмана из вершины s
     fordBellman(s)
     // m — длина оптимального цикла
     m = minumaxk((d[n][u] - d[k][u]) / (n - k))
